# Internal filename: /usr/lib/enigma2/python/Components/Converter/EventInfo.py# Bytecode version: 3.12.0rc2 (3531)# Source timestamp: 2051-05-14 21:29:46 UTC (2567712586)from time import localtime, mktime, strftime, timefrom enigma import eEPGCache, eServiceEventEnums, eServiceReference, iServiceInformationfrom ServiceReference import ServiceReferencefrom Components.config import configfrom Components.Element import cachedfrom Components.Converter.genre import getGenreStringSubfrom Components.Converter.Converter import Converterfrom Components.Converter.Poll import Pollfrom Tools.Conversions import UnitScalerfrom Tools.Directories import SCOPE_GUISKIN, resolveFilenameclass Metrixfhd_neo_EventInfo(Converter, Poll):    # Alle Tokens wie im Original    CRID_EPISODE = 0    CRID_RECOMMENDATION = 1    CRID_SERIES = 2    DURATION = 3    ELAPSED = 4    ELAPSED_VFD = 5    END_TIME = 6    EPG_SOURCE = 7    EXTENDED_DESCRIPTION = 8    EXTRA_DATA = 9    FILE_SIZE = 10    FULL_DESCRIPTION = 11    GENRE = 12    GENRE_LIST = 13    ID = 14    MEDIA_PATH = 15    NAME = 16    NAME_NEXT = 17    NAME_NEXT2 = 18    NAME_NOW = 19    NEXT_DESCRIPTION = 20    NEXT_DURATION = 21    NEXT_END_TIME = 22    NEXT_START_TIME = 23    NEXT_TIMES = 24    PDC = 25    PDC_TIME = 26    PDC_TIME_SHORT = 27    PROGRESS = 28    RATING = 29    RATING_CODE = 30    RATING_COUNTRY = 31    RATING_ICON = 32    RATING_RAW = 33    REMAINING = 34    REMAINING_VFD = 35    RUNNING_STATUS = 36    SERVICE_NAME = 37    SERVICE_REFERENCE = 38    SHORT_DESCRIPTION = 39    START_TIME = 40    THIRD_DESCRIPTION = 41    THIRD_DURATION = 42    THIRD_END_TIME = 43    THIRD_NAME = 44    THIRD_NAME2 = 45    THIRD_START_TIME = 46    THIRD_TIMES = 47    TIMES = 48    def __init__(self, type):        Converter.__init__(self, type)        Poll.__init__(self)        self.epgCache = eEPGCache.getInstance()        self.token = getattr(self, type.upper(), self.NAME)        self.poll_interval = 60000 if self.token in (self.ELAPSED, self.REMAINING, self.PROGRESS) else 0        self.poll_enabled = self.poll_interval > 0    @cached    def getBoolean(self):        event = self.source.event        if self.token == self.PDC:            return bool(event and event.getPdcPil())        return bool(self.getText())    boolean = property(getBoolean)    @cached    def getText(self):        event = self.source.event        if not event:            return ""        # Name & Beschreibungen        if self.token == self.NAME:            return event.getEventName() or ""        elif self.token == self.NAME_NOW:            return f"Now: {event.getEventName()}"        elif self.token == self.SHORT_DESCRIPTION:            return event.getShortDescription() or ""        elif self.token == self.EXTENDED_DESCRIPTION:            return event.getExtendedDescription() or ""        elif self.token == self.FULL_DESCRIPTION:            return (event.getShortDescription() or "") + "\n" + (event.getExtendedDescription() or "")        # PDC        elif self.token == self.PDC:            return "PDC" if event.getPdcPil() else ""        elif self.token in (self.PDC_TIME, self.PDC_TIME_SHORT):            pdc = event.getPdcPil()            if pdc:                begin = localtime(event.getBeginTime())                start = localtime(mktime((begin.tm_year, (pdc & 0x7800) >> 11,                                          (pdc & 0x1F800) >> 15, (pdc & 0x7C0) >> 6,                                          pdc & 0x3F, 0, begin.tm_wday, begin.tm_yday, begin.tm_isdst)))                fmt = config.usage.time.short.value if self.token == self.PDC_TIME_SHORT else f"{config.usage.date.short.value} {config.usage.time.short.value}"                return strftime(fmt, start)            return ""        # Service Infos        elif self.token == self.SERVICE_NAME:            info = self.source.info            serviceReference = self.source.service            if info and serviceReference:                return ServiceReference(info.getInfoString(serviceReference, iServiceInformation.sServiceref)).getServiceName()        elif self.token == self.SERVICE_REFERENCE:            return self.source.service and self.source.service.toString() or ""        # Genre Infos        elif self.token in (self.GENRE, self.GENRE_LIST):            genres = event.getGenreDataList() or []            if self.token == self.GENRE and genres:                return getGenreStringSub(genres[0][0], genres[0][1])            else:                return ", ".join([getGenreStringSub(g[0], g[1]) for g in genres])        # Ratings        elif self.token in (self.RATING, self.RATING_CODE, self.RATING_RAW):            rating = event.getParentalData()            if not rating:                return ""            if self.token == self.RATING_RAW:                return str(rating.getRating())            return rating.getCountryCode().upper()        # Next & Third Events (aus EPG Cache)        elif self.token in (self.NAME_NEXT, self.NAME_NEXT2, self.NEXT_DESCRIPTION, self.THIRD_NAME, self.THIRD_NAME2, self.THIRD_DESCRIPTION):            epgData = self._getEpgData()            index = 1 if self.token in (self.NAME_NEXT, self.NAME_NEXT2, self.NEXT_DESCRIPTION) else 2            if len(epgData) > index:                if self.token in (self.NAME_NEXT, self.THIRD_NAME):                    label = "Next" if index == 1 else "Later"                    return f"{label}: {epgData[index][1]}"                elif self.token in (self.NAME_NEXT2, self.THIRD_NAME2):                    return epgData[index][1]                elif self.token in (self.NEXT_DESCRIPTION, self.THIRD_DESCRIPTION):                    return (epgData[index][2] or "") + "\n" + (epgData[index][3] or "")        return ""    text = property(getText)    def _getEpgData(self):        serviceReference = self.source.service        if serviceReference and self.epgCache:            return self.epgCache.lookupEvent(['ITBD', (serviceReference.toString(), 0, -1, 1440)]) or []        return []    @cached    def getTime(self):        event = self.source.event        if not event:            return None        start = event.getBeginTime()        duration = event.getDuration()        end = start + duration        if self.token == self.START_TIME:            return start        elif self.token == self.END_TIME:            return end        elif self.token == self.DURATION:            return duration        elif self.token == self.TIMES:            return (start, end)        elif self.token in (self.ELAPSED, self.REMAINING):            now = int(time())            elapsed = max(0, now - start)            remaining = max(0, end - now)            return elapsed if self.token == self.ELAPSED else remaining        return None    time = property(getTime)    @cached    def getValue(self):        if self.token == self.PROGRESS:            event = self.source.event            if event:                progress = int(time()) - event.getBeginTime()                duration = event.getDuration()                if duration > 0:                    if progress > duration:                        progress = duration                    return progress * 1000 // duration        return None    value = property(getValue)    range = 1000    def changed(self, what):        Converter.changed(self, what)        if self.token == self.PROGRESS and self.downstream_elements:            self.downstream_elements[0].visible = bool(self.source.event)